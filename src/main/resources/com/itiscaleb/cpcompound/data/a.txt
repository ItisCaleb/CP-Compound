#pragma GCC optimize("O3,unroll-loops")
#pragma target optimize("avx2,bmi,bmi2,lzcnt,popcnt")
#include <bits/stdc++.h>
#define IO ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define int long long
#define pii pair<int, int>
using namespace std;
const int INF = LONG_LONG_MAX;
const int MXN = 1010;
int n;
struct Dinic
{
    struct Edge
    {
        int v, f, re;
    };
    int n, s, t, level[MXN];
    vector<Edge> E[MXN];
    void init(int _n, int _s, int _t)
    {
        n = _n;
        s = _s;
        t = _t;
        for (int i = 0; i < n; i++)
            E[i].clear();
    }
    void add_edge(int u, int v, int f)
    {
        // cerr<<u<<" "<<v<<" "<<f<<"\n";
        E[u].push_back({v, f, (int)(E[v]).size()});
        E[v].push_back({u, 0, (int)(E[u]).size() - 1});
    }
    bool BFS()
    {
        for (int i = 0; i < n; i++)
            level[i] = -1;
        queue<int> que;
        que.push(s);
        level[s] = 0;
        while (!que.empty())
        {
            int u = que.front();
            que.pop();
            for (auto it : E[u])
            {
                if (it.f > 0 && level[it.v] == -1)
                {
                    level[it.v] = level[u] + 1;
                    que.push(it.v);
                }
            }
        }
        return level[t] != -1;
    }
    int DFS(int u, int nf)
    {
        if (u == t)
            return nf;
        int res = 0;
        for (auto &it : E[u])
        {
            if (it.f > 0 && level[it.v] == level[u] + 1)
            {
                int tf = DFS(it.v, min(nf, it.f));
                res += tf;
                nf -= tf;
                it.f -= tf;
                E[it.v][it.re].f += tf;
                if (nf == 0)
                    return res;
            }
        }
        if (!res)
            level[u] = -1;
        return res;
    }
    int solve(int res = 0)
    {
        while (BFS())
            res += DFS(s, 2147483647);
        return res;
    }
} flow1,flow2 ;
int arr[1000];
vector<int> dp;
int getLIS()
{
    dp.resize(n+1,1);
    int LIS = 1;
    for (int i = 1; i <= n; i++)
        for (int j = i + 1; j <= n; j++)
            if (arr[i] <= arr[j])
                dp[j] = max(dp[j], dp[i] + 1);

    for (int i = 1; i <= n; i++)
        LIS = max(LIS, dp[i]);
    return LIS;
}
signed main()
{
    IO
    int LIS = 0;
    cin >> n;
    if (n == 1)
    {
        cout << "1\n1\n1\n";
        return 0;
    }

    for (int i = 1; i <= n; i++)
        cin >> arr[i];
    LIS = getLIS();

    int S = 0, T = 2 * n + 1;
    flow1.init(2 * n + 2, S, T);
    for (int i = 1; i <= n; ++i)
    {
        if (dp[i] == 1)
            flow1.add_edge(S, i, 1);
        if (dp[i] == LIS)
            flow1.add_edge(i + n, T, 1);
        flow1.add_edge(i, n + i, 1);
    }
    for (int i = 1; i <= n; ++i)
        for (int j = i + 1; j <= n; ++j)
            if (arr[i] <= arr[j] && dp[i] + 1 == dp[j])
                flow1.add_edge(i + n, j, 1);
    flow2.init(2 * n + 2, S, T);
    for (int i = 1; i <= n; i++)
    {
        if (i == 1 || i == n)
            flow2.add_edge(i, i + n, INF);
        else
            flow2.add_edge(i, i + n, 1);
    }
    for (int i = 1; i <= n; i++)
    {
        if (dp[i] == 1)
        {
            if (i == 1)
                flow2.add_edge(0, i, INF);
            else
                flow2.add_edge(0, i, 1);
        }
        if (dp[i] == LIS)
        {
            if (i == n)
                flow2.add_edge(i + n, 2 * n + 1, INF);
            else
                flow2.add_edge(i + n, 2 * n + 1, 1);
        }
    }
    for (int i = 1; i <= n; i++)
        for (int j = i + 1; j <= n; j++)
            if (arr[i] <= arr[j] && dp[i] + 1 == dp[j])
                flow2.add_edge(i + n, j, 1);
    cout << LIS << "\n" << flow1.solve() << "\n" << flow2.solve() << "\n";

    return 0;
}